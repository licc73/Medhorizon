//
//  KTJSONAPIQuery.swift
//  Knuth
//
//  Created by ChenYong on 11/24/15.
//  Copyright Â© 2015 Autodesk. All rights reserved.
//

import Foundation

let defaultServerDateFormatter = getDefaultServerDateFormatter()

func getDefaultServerDateFormatter() -> NSDateFormatter {
    let formatter = NSDateFormatter()
    formatter.timeZone = NSTimeZone(name: "UTC")
    formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
    formatter.locale = NSLocale(localeIdentifier: "en_US_POSIX")
    return formatter
}

let filterKeyword = "filter"
let sortKeyword = "sort"
let includeKeyword = "include"
let fieldsKeyword = "fields"
let pageKeyword = "page"


extension Array {

    /**
     Creates an array with values generated by running each value of self
     through the mapFunction and discarding nil return values.

     :param: mapFunction
     :returns: Mapped array
     */
//    func mapFilter <V> (mapFunction map: (Element) -> (V)?) -> [V] {
//        var mapped = [V]()
//        for item in self {
//            if let mappedValue = map(item) {
//                mapped.append(mappedValue)
//            }
//        }
//        return mapped
//
//    }

    /**
     Converts the array to a dictionary with the keys supplied via the keySelector.

     :param: keySelector
     :returns: A dictionary
     */

    func toDictionary <U> (keySelector: (Element) -> U) -> [U: Element] {
        var result: [U: Element] = [:]
        for item in self {
            result[keySelector(item)] = item
        }

        return result
    }

    /**
     Converts the array to a dictionary with keys and values supplied via the transform function.

     :param: transform
     :returns: A dictionary
     */
    func toDictionary <K, V> (transform: (Element) -> (key: K, value: V)?) -> [K: V] {
        var result: [K: V] = [:]
        for item in self {
            if let entry = transform(item) {
                result[entry.key] = entry.value
            }
        }

        return result

    }
    
}


extension Dictionary {
    /**
     Creates a Dictionary with the same keys as self and values generated by running
     each [key: value] of self through the mapFunction discarding nil return values.

     :param: mapFunction
     :returns: Mapped dictionary
     */

    func mapFilterValues <V> (map: (Key, Value) -> V?) -> [Key: V] {

        var mapped = [Key: V]()

        for (key, value) in self {
            if let value = map(key, value) {
                mapped[key] = value
            }
        }
        return mapped

    }

    /**
     Creates an Array with values generated by running
     each [key: value] of self through the mapFunction.

     :param: mapFunction
     :returns: Mapped array
     */
    func toArrayFilter <V> (map: (Key, Value) -> V?) -> [V] {

        var mapped = [V]()

        for (key, value) in self {
            if let m = map(key, value) {
                mapped.append(m)
            }
        }

        return mapped
    }


}

public func toURLQueryTuples(paramters: [String: AnyObject]) -> [(String, String)] {
    return paramters.toArrayFilter { (key, object) -> [(String, String)]? in
        if let parameterObject = object as? [String: AnyObject] {
            switch key {
            case filterKeyword, pageKeyword:
                return toQueryString(key, paramters: parameterObject)
            case fieldsKeyword, sortKeyword:
                //
                // TODO: fields support required here
                //
                //
                // TODO: sort support required here
                //
                return nil
            default:
                return toQueryString(key, paramters: parameterObject)
            }
        } else if let parameterString = object as? String {
            return [(key, parameterString)]
        } else if let paramterStrings = object as? [String] where !paramterStrings.isEmpty {
            return [(key, paramterStrings.joinWithSeparator(","))]
        } else {
            return nil
        }
    }.flatten().map {$0}
}

public func toURLQueryDict(paramters: [String: AnyObject]) -> [String: String] {
    return toURLQueryTuples(paramters).toDictionary {$0}
}

public func toURLQueryString(paramters: [String: AnyObject]) -> String {
    return toURLQueryTuples(paramters).map {$0+"="+$1}.joinWithSeparator("&")
}

func appendPrefix(prefix: String, key: String) -> String {
    return prefix.isEmpty ? key : prefix + "[\(key)]"
}

public func toQueryString(prefix: String, paramters: [AnyObject]) -> [ (String, String) ] {
    return paramters.flatMap { object -> (String, String)? in
        if let s = object as? String {
            return (prefix + "[]", s)
        } else if let n = object as? NSNumber {
            return (prefix + "[]", String(format: "%@", n))
        } else {
            return nil
        }
    }
}

public func toQueryString(prefix: String, paramters: [String: AnyObject]) -> [ (String, String) ] {
    return paramters.flatMap { (key, object) -> [(String, String)] in
        let newPrefix = appendPrefix(prefix, key: key)
        if let o = object as? [String: AnyObject] {
             return toQueryString(newPrefix, paramters: o)
        } else if let s = object as? String {
            return [(newPrefix, s)]
        } else if let n = object as? NSNumber {
            return [(newPrefix, String(format: "%@", n))]
        } else if let a = object as? [AnyObject] {
            return toQueryString(newPrefix, paramters: a)
        } else if let d = object as? NSDate {
            return [(newPrefix, defaultServerDateFormatter.stringFromDate(d))]
        } else {
            return []
        }
    }
}

extension NSDate : Comparable {

}

public func ==(lhs: NSDate, rhs: NSDate) -> Bool {
    return lhs === rhs || lhs.compare(rhs) == .OrderedSame
}

public func <(lhs: NSDate, rhs: NSDate) -> Bool {
    return lhs.compare(rhs) == .OrderedAscending
}
